---
name: CI

permissions:
  contents: read
  packages: write

'on':
  push: {}
  pull_request: {}

jobs:
  validate:
    name: Validate workflow YAML
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install PyYAML
        run: python -m pip install --user pyyaml

      - name: Validate workflows
        run: |
          python - <<'PY'
          import yaml,sys,glob
          ok=True
          for p in glob.glob('.github/workflows/*.yml'):
              try:
                  yaml.safe_load(open(p))
                  print(p, 'OK')
              except Exception as e:
                  print(p, 'ERROR', e)
                  ok=False
          if not ok:
              sys.exit(1)
          print('All workflow YAML parsed successfully')
          PY

  determine-changed:
    name: Determine changed services
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.set.outputs.services }}
    steps:
      - uses: actions/checkout@v4

      - name: Determine changed services
        id: set
        run: |
          git fetch origin main --depth=1 || true
          CHANGED_FILES=$(git diff --name-only origin/main...HEAD || true)
          echo "Changed files: $CHANGED_FILES"
          SERVICES_LIST=()
          CHECK_DIRS=(
            auth
            admin-service
            order
            food-delivery-server
            payment-service
            notification-service
            restaurant
          )
          for d in "${CHECK_DIRS[@]}"; do
            if echo "$CHANGED_FILES" | grep -q "^$d/"; then
              SERVICES_LIST+=("$d")
            fi
          done
          if [ ${#SERVICES_LIST[@]} -eq 0 ]; then
            SERVICES_LIST=("${CHECK_DIRS[@]}")
          fi
          ARR=""
          for s in "${SERVICES_LIST[@]}"; do
            if [ -z "$ARR" ]; then ARR="\"$s\""; else ARR="$ARR,\"$s\""; fi
          done
          JSON="[$ARR]"
          echo "services=$JSON" >> $GITHUB_OUTPUT

  unit-tests:
    name: Run unit tests for changed services
    runs-on: ubuntu-latest
    needs: determine-changed
    steps:
      - uses: actions/checkout@v4

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Run tests for changed services
        id: run-tests
        env:
          SERVICES_JSON: ${{ needs.determine-changed.outputs.services }}
        run: |
          set -euo pipefail
          echo "Services JSON: $SERVICES_JSON"
          if [ -z "$SERVICES_JSON" ] || [ "$SERVICES_JSON" = '[]' ]; then
            echo "No changed services; skipping unit-tests"
            exit 0
          fi
          mkdir -p test-reports
          any_fail=0
          for svc in $(echo "$SERVICES_JSON" | jq -r '.[]'); do
            safe_svc=${svc//\//-}
            # Only run tests if package.json exists
            if [ ! -f "$svc/package.json" ]; then
              echo "No package.json in $svc; skipping"
              continue
            fi
            echo "Checking $svc for tests"
            # Prefer an explicit unit test script when present
            if grep -q '"test:unit"' "$svc/package.json"; then
              TEST_CMD="npm run test:unit --"
            elif grep -q '"test"' "$svc/package.json"; then
              TEST_CMD="npm test --"
            else
              echo "No test script in $svc/package.json; skipping"
              continue
            fi

            echo "Running tests for $svc using: $TEST_CMD"
            pushd $svc
            # Install deps: prefer npm ci when lockfile exists
            if [ -f package-lock.json ]; then
              npm ci --silent || { echo "npm ci failed for $svc"; any_fail=1; popd; continue; }
            else
              npm install --silent || { echo "npm install failed for $svc"; any_fail=1; popd; continue; }
            fi
              # Run tests and capture exit code + report (do not abort loop)
              # Use the chosen command; ensure Jest outputs JSON to the reports dir
              if [ "${TEST_CMD#npm run}" != "$TEST_CMD" ]; then
                # TEST_CMD starts with 'npm run', execute via sh -c to preserve args
                sh -c "$TEST_CMD --json --outputFile=../test-reports/${safe_svc}-jest.json" || rc=$?
              else
                $TEST_CMD --json --outputFile=../test-reports/${safe_svc}-jest.json || rc=$?
              fi
              rc=${rc:-0}
            if [ "$rc" -ne 0 ]; then
              echo "Tests failed for $svc with exit code $rc"
              any_fail=1
            else
              echo "Tests passed for $svc"
            fi
            unset rc
            popd
          done

          if [ "$any_fail" -ne 0 ]; then
            echo "One or more unit test suites failed"
            exit 1
          fi

      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: unit-test-reports
          path: test-reports


  build-images:
    name: Build images
    runs-on: ubuntu-latest
    needs: determine-changed
    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Check GHCR cache
        id: cache-check
        env:
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
          REPO_OWNER: ${{ github.repository_owner }}
        run: |
          set -e
          AUTH=${GHCR_PAT:-$GITHUB_TOKEN}
          if [ -z "$AUTH" ]; then
            echo "No registry credentials available; assuming no cache" >> /dev/stderr
            echo "cache_exists=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          status=$(curl -s -o /dev/null -w "%{http_code}" \
            -u "${GITHUB_ACTOR}:${AUTH}" \
            "https://ghcr.io/v2/${REPO_OWNER}/cnpm-build-cache/manifests/cache" || echo "000")
          if [ "$status" = "200" ]; then
            echo "cache_exists=true" >> $GITHUB_OUTPUT
          else
            echo "cache_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Build changed service images
        env:
          SERVICES_JSON: ${{ needs.determine-changed.outputs.services }}
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CACHE_EXISTS: ${{ steps.cache-check.outputs.cache_exists }}
        run: |
          set -euo pipefail
          echo "Services JSON: $SERVICES_JSON"
          if [ -z "$SERVICES_JSON" ] || [ "$SERVICES_JSON" = '[]' ]; then
            echo "No services to build"
            exit 0
          fi
          GHCR_AUTH=false
          AUTH=${GHCR_PAT:-$GITHUB_TOKEN}
          if [ -n "$AUTH" ]; then
            echo "Attempting to login to GHCR to enable registry push/pull"
            if echo "$AUTH" | docker login ghcr.io -u ${{ github.actor }} --password-stdin; then
              GHCR_AUTH=true
            else
              echo "Warning: GHCR login failed; proceeding with local builds only" >&2
            fi
          else
            echo "No registry credentials found; will build locally" >&2
          fi

          owner_lower=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1 | tr '[:upper:]' '[:lower:]')
          CACHE_REPO=${CACHE_REPO:-ghcr.io/${owner_lower}/cnpm-build-cache}

          if [ "$GHCR_AUTH" = "true" ]; then
            echo "Credentials present - will push to GHCR and use registry cache"
            echo "Using cache repo: ${CACHE_REPO}"
            for svc in $(echo "$SERVICES_JSON" | jq -r '.[]'); do
              safe_svc=${svc//\//-}
              gh_image=ghcr.io/${owner_lower}/cnpm-${safe_svc}:sha-${GITHUB_SHA}
              echo "Building and pushing $svc -> $gh_image"
              cache_flags=()
              if [ "${CACHE_EXISTS:-false}" = "true" ] && [ -n "${CACHE_REPO}" ]; then
                echo "Registry cache exists; using cache flags"
                cache_flags=(
                  --cache-from=type=registry,ref=${CACHE_REPO}:cache
                  --cache-to=type=registry,ref=${CACHE_REPO}:cache,mode=max
                )
              else
                echo "Registry cache missing or unavailable; building without registry cache"
              fi
              docker buildx build \
                --push \
                --tag ${gh_image} \
                "${cache_flags[@]}" \
                ./$svc
              # try to pull the pushed image to populate local cache; if pull fails, continue but don't abort workflow
              if docker pull ${gh_image}; then
                docker tag ${gh_image} ci-${safe_svc}:latest
              else
                echo "Warning: pulled image ${gh_image} not available locally after push" >&2
              fi
            done
          else
            echo "No GHCR credentials — building images locally and loading into docker"
            for svc in $(echo "$SERVICES_JSON" | jq -r '.[]'); do
              safe_svc=${svc//\//-}
              if [ -d "./$svc" ]; then
                echo "Building local image ci-${safe_svc}:latest from ./$svc"
                docker buildx build --load --tag ci-${safe_svc}:latest ./$svc
              else
                echo "Service directory ./$svc not found; skipping local build" >&2
              fi
            done
          fi

      - name: Ensure local images for smoke-tests
        env:
          SERVICES_JSON: ${{ needs.determine-changed.outputs.services }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          echo "Ensuring local images for smoke-tests"
          if [ -z "${SERVICES_JSON:-}" ] || [ "${SERVICES_JSON}" = '[]' ]; then
            echo "No services to ensure"
            exit 0
          fi
          owner_lower=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1 | tr '[:upper:]' '[:lower:]')
          for svc in $(echo "$SERVICES_JSON" | jq -r '.[]'); do
            safe_svc=${svc//\//-}
            if docker image inspect ci-${safe_svc}:latest >/dev/null 2>&1; then
              echo "Local image ci-${safe_svc}:latest already present"
              continue
            fi
            pulled=false
            for tag in "sha-${GITHUB_SHA}" "latest"; do
              gh_image=ghcr.io/${owner_lower}/cnpm-${safe_svc}:$tag
              echo "Attempting to pull ${gh_image}"
              if docker pull ${gh_image}; then
                docker tag ${gh_image} ci-${safe_svc}:latest
                pulled=true
                break
              else
                echo "Pull failed for ${gh_image} — will try next tag if available"
              fi
            done
            if [ "$pulled" = "true" ]; then
              continue
            fi
            echo "No image in GHCR for ${svc} or all pulls failed; building local image"
            if [ -d "./$svc" ]; then
              docker buildx build --load --tag ci-${safe_svc}:latest ./$svc
            else
              echo "Service directory ./$svc not found; skipping local build"
            fi
          done

  service-smoke-tests:
    name: Service smoke tests
    runs-on: ubuntu-latest
    needs: [determine-changed, build-images]
    steps:
      - uses: actions/checkout@v4

      - name: Optionally set GHCR credentials env
        env:
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "GHCR_PAT present: ${GHCR_PAT:+yes}"
          echo "GITHUB_TOKEN present: ${GITHUB_TOKEN:+yes}"

      - name: Install jq and curl
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Run smoke tests for changed services
        env:
          SERVICES_JSON: ${{ needs.determine-changed.outputs.services }}
        run: |
          set -euo pipefail
          echo "Services JSON: $SERVICES_JSON"
          if [ -z "$SERVICES_JSON" ] || [ "$SERVICES_JSON" = '[]' ]; then
            echo "No changed services; skipping smoke-tests"
            exit 0
          fi
          docker network create ci-net || true
          docker run -d --name ci-mongo --network ci-net mongo:6
          sleep 5
          declare -A PORT_MAP
          PORT_MAP=(
            ["auth-service"]=5001
            ["order-service"]=5002
            ["delivery-service"]=5004
            ["payment-service"]=5005
            ["notification-service"]=5007
            ["restaurant"]=5006
          )
          for svc in $(echo "$SERVICES_JSON" | jq -r '.[]'); do
            safe_svc=${svc//\//-}
            port=${PORT_MAP[$svc]:-}
            if [ -z "$port" ]; then
              echo "No port mapping for $svc; skipping"
              continue
            fi
            # Prefer local ci-<service>:latest image if exists
            if docker image inspect ci-${safe_svc}:latest >/dev/null 2>&1; then
              gh_image=ci-${safe_svc}:latest
            else
              owner_lower=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1 | tr '[:upper:]' '[:lower:]')
              pulled=false
              for tag in "sha-${GITHUB_SHA}" "latest"; do
                gh_image=ghcr.io/${owner_lower}/cnpm-${safe_svc}:$tag
                echo "Attempting to pull $gh_image from GHCR"
                if docker pull $gh_image; then
                  pulled=true
                  break
                else
                  echo "Pull failed for $gh_image"
                fi
              done
              if [ "$pulled" = "false" ]; then
                echo "No image available for $svc; skipping"
                continue
              fi
            fi
            echo "Running $svc on port $port"
            env_args=""
            case "$svc" in
              auth|auth-service)
                env_args="-e PORT=$port -e MONGO_URI=mongodb://ci-mongo:27017/auth_test"
                ;;
              order|order-service)
                env_args="-e PORT=$port -e MONGODB_URI=mongodb://ci-mongo:27017/order_test"
                ;;
              delivery|delivery-service)
                env_args="-e PORT=$port -e DELIVERY_MONGO_URI=mongodb://ci-mongo:27017/delivery_test"
                ;;
              payment|payment-service)
                env_args="-e PORT=$port -e MONGO_URI=mongodb://ci-mongo:27017/payment_test"
                ;;
              notification|notification-service)
                env_args="-e PORT=$port -e MONGO_URI=mongodb://ci-mongo:27017/notifications_test -e ENABLE_KAFKA=false"
                ;;
              restaurant)
                env_args="-e PORT=$port -e MONGOURL=mongodb://ci-mongo:27017/restaurant_test"
                ;;
              *)
                env_args="-e PORT=$port -e MONGO_URI=mongodb://ci-mongo:27017/test"
                ;;
            esac
            docker run -d --name ci-${safe_svc} --network ci-net \
              -p ${port}:${port} $env_args $gh_image \
              || (echo "Failed to start $svc" && exit 1)
            ok=0
            for i in $(seq 1 12); do
              if curl -sS --max-time 2 http://localhost:${port}/metrics >/dev/null 2>&1; then ok=1; break; fi
              if curl -sS --max-time 2 http://localhost:${port}/health >/dev/null 2>&1; then ok=1; break; fi
              if curl -sS --max-time 2 http://localhost:${port}/ >/dev/null 2>&1; then ok=1; break; fi
              sleep 2
            done
            if [ $ok -ne 1 ]; then
              docker logs ci-${safe_svc} --tail 200 || true
              echo "Service $svc failed startup checks" && exit 1
            fi
            echo "$svc is healthy"
          done
          echo "All tested services are healthy"

  integration-tests:
    name: Integration tests (container-backed)
    runs-on: ubuntu-latest
    needs: [determine-changed, build-images]
    env:
      SERVICES_JSON: ${{ needs.determine-changed.outputs.services }}
    steps:
      - uses: actions/checkout@v4

      - name: Install jq and curl
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Start integration network and DB
        run: |
          set -euo pipefail
          echo "Services JSON: $SERVICES_JSON"
          if [ -z "$SERVICES_JSON" ] || [ "$SERVICES_JSON" = '[]' ]; then
            echo "No changed services; skipping integration-tests"
            exit 0
          fi
          docker network create ci-net || true
          docker run -d --name ci-mongo --network ci-net mongo:6
          sleep 5
          declare -A PORT_MAP
          PORT_MAP=(
            ["auth-service"]=5001
            ["order-service"]=5002
            ["delivery-service"]=5004
            ["payment-service"]=5005
            ["notification-service"]=5007
            ["restaurant"]=5006
            ["food-delivery-server"]=5000
          )
          owner_lower=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f1 | tr '[:upper:]' '[:lower:]')
          for svc in $(echo "$SERVICES_JSON" | jq -r '.[]'); do
            safe_svc=${svc//\//-}
            port=${PORT_MAP[$svc]:-}
            if [ -z "$port" ]; then
              echo "No port mapping for $svc; skipping"
              continue
            fi
            if docker image inspect ci-${safe_svc}:latest >/dev/null 2>&1; then
              gh_image=ci-${safe_svc}:latest
            else
              pulled=false
              for tag in "sha-${GITHUB_SHA}" "latest"; do
                gh_image=ghcr.io/${owner_lower}/cnpm-${safe_svc}:$tag
                echo "Attempting to pull $gh_image"
                if docker pull $gh_image; then
                  pulled=true
                  break
                fi
              done
              if [ "$pulled" = "false" ]; then
                echo "No image available for $svc; skipping"
                continue
              fi
            fi
            echo "Running $svc on port $port"
            env_args=""
            case "$svc" in
              auth|auth-service)
                env_args="-e PORT=$port -e MONGO_URI=mongodb://ci-mongo:27017/auth_test"
                ;;
              order|order-service)
                env_args="-e PORT=$port -e MONGODB_URI=mongodb://ci-mongo:27017/order_test"
                ;;
              delivery|delivery-service)
                env_args="-e PORT=$port -e DELIVERY_MONGO_URI=mongodb://ci-mongo:27017/delivery_test"
                ;;
              payment|payment-service)
                env_args="-e PORT=$port -e MONGO_URI=mongodb://ci-mongo:27017/payment_test"
                ;;
              notification|notification-service)
                env_args="-e PORT=$port -e MONGO_URI=mongodb://ci-mongo:27017/notifications_test -e ENABLE_KAFKA=false"
                ;;
              restaurant)
                env_args="-e PORT=$port -e MONGOURL=mongodb://ci-mongo:27017/restaurant_test"
                ;;
              food-delivery-server)
                env_args="-e PORT=$port -e MONGO_URI=mongodb://ci-mongo:27017/foodapp_test"
                ;;
              *)
                env_args="-e PORT=$port -e MONGO_URI=mongodb://ci-mongo:27017/test"
                ;;
            esac
            docker run -d --name ci-${safe_svc} --network ci-net -p ${port}:${port} $env_args $gh_image || (echo "Failed to start $svc" && exit 1)
          done

      - name: Run integration tests for changed services
        env:
          SERVICES_JSON: ${{ needs.determine-changed.outputs.services }}
        run: |
          set -euo pipefail
          mkdir -p integration-reports
          any_fail=0
          for svc in $(echo "$SERVICES_JSON" | jq -r '.[]'); do
            safe_svc=${svc//\//-}
            if [ ! -f "$svc/package.json" ]; then
              echo "No package.json in $svc; skipping integration tests"
              continue
            fi
            echo "Checking $svc for integration tests"
            if grep -q '"test:integration"' "$svc/package.json"; then
              TEST_CMD="npm run test:integration --"
            elif grep -q '"test"' "$svc/package.json"; then
              TEST_CMD="npm test --"
            else
              echo "No test script in $svc/package.json; skipping"
              continue
            fi
            echo "Running integration tests for $svc using: $TEST_CMD"
            pushd $svc
            if [ -f package-lock.json ]; then
              npm ci --silent || { echo "npm ci failed for $svc"; any_fail=1; popd; continue; }
            else
              npm install --silent || { echo "npm install failed for $svc"; any_fail=1; popd; continue; }
            fi
            sh -c "$TEST_CMD" || rc=$?
            rc=${rc:-0}
            if [ "$rc" -ne 0 ]; then
              echo "Integration tests failed for $svc with exit code $rc"
              any_fail=1
            else
              echo "Integration tests passed for $svc"
            fi
            unset rc
            popd
          done
          if [ "$any_fail" -ne 0 ]; then
            echo "One or more integration test suites failed"
            exit 1
          fi

      - name: Tear down integration containers
        if: always()
        run: |
          set -e
          for c in $(docker ps -a --filter "name=ci-" --format "{{.Names}}"); do docker rm -f $c || true; done
          docker network rm ci-net || true

      - name: Upload integration reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-reports
          path: integration-reports

      - name: Cleanup containers and network
        run: |
          set -e || true
          docker ps -aq | xargs -r docker rm -f || true
          docker network rm ci-net || true
