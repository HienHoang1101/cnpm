# GitLab CI configuration for the mono-repo
# - Runs per-service unit tests in parallel using GitLab matrix
# - Builds Docker images and optionally pushes to GitLab Container Registry
# - Provides a manual deploy job as a placeholder for your environment (K8s/SSH/etc.)

stages:
  - test
  - build
  - deploy

variables:
  NODE_IMAGE: node:20

# Per-service unit tests using parallel matrix
unit_tests:
  stage: test
  image: $NODE_IMAGE
  parallel:
    matrix:
      - SERVICE: ["auth","payment-service","order","admin-service","restaurant","notification-service","food-delivery-server"]
  before_script:
    - echo "Running unit tests for service: $SERVICE"
    - if [ -d "$SERVICE" ]; then cd "$SERVICE"; else echo "Service $SERVICE not present — skipping"; exit 0; fi
    - if [ -f package-lock.json ]; then npm ci --no-audit --no-fund; else npm install --no-audit --no-fund; fi
  script:
    - |
      set -e
      # Try to run Jest with JSON output so we can preserve results as artifacts.
      # Many services already include a `test:unit` script; prefer it when available.
      if grep -q '"test:unit"' package.json; then
        echo "Using test:unit"
        node --experimental-vm-modules node_modules/jest/bin/jest.js --runInBand --json --outputFile=jest-results.json || true
      else
        echo "Falling back to npm test"
        # npm test may be a shell echo in some packages; attempt to run jest directly as fallback
        if [ -f node_modules/.bin/jest ]; then
          node --experimental-vm-modules node_modules/jest/bin/jest.js --runInBand --json --outputFile=jest-results.json || true
        else
          npm test || true
        fi
      fi
  artifacts:
    when: always
    paths:
      - $SERVICE/jest-results.json
      - $SERVICE/npm-debug.log
    expire_in: 1 week

# Build Docker images for each service and push if registry credentials are present
build_images:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  variables:
    DOCKER_DRIVER: overlay2
  script:
    - echo "Building and optionally pushing images for services"
    - |
      set -e
      for svc in auth payment-service order admin-service restaurant notification-service food-delivery-server; do
        if [ -d "$svc" ]; then
          echo "Building image for $svc"
          tag="$CI_REGISTRY_IMAGE/$svc:$CI_COMMIT_SHORT_SHA"
          docker build -t "$tag" "$svc"
          if [ -n "$CI_REGISTRY" ] && [ -n "$CI_REGISTRY_USER" ] && [ -n "$CI_REGISTRY_PASSWORD" ]; then
            echo "Logging in to registry $CI_REGISTRY"
            echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY" || true
            docker push "$tag" || echo "Push failed for $tag"
          else
            echo "Registry credentials not set — skipping push for $svc"
          fi
        else
          echo "Directory $svc not found — skipping"
        fi
      done
  only:
    - main
    - master
    - /^release-.*$/

# Manual deploy placeholder — replace with your deployment steps (kubectl, helm, ssh)
deploy:
  stage: deploy
  image: alpine:3.18
  script:
    - echo "Deploy job placeholder — configure this job for your environment"
  when: manual
  only:
    - main
    - master
